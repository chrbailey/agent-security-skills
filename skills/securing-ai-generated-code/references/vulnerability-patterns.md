# Vulnerability Patterns Reference

Extended examples, framework-specific gotchas, and OWASP mappings for the 8 AI-specific vulnerability patterns. This supplements the main [SKILL.md](../SKILL.md).

---

## 1. Hardcoded Secrets

**OWASP:** [A07:2021 - Identification and Authentication Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/)

**AI tendency:** Models generate credentials inline because training data contains thousands of examples with placeholder or real keys. GPT and Claude models frequently produce `AKIA` AWS key prefixes, `sk-` OpenAI prefixes, and `ghp_` GitHub token prefixes.

### Python

BAD:
```python
import boto3

client = boto3.client(
    "s3",
    aws_access_key_id="AKIAIOSFODNN7EXAMPLE",
    aws_secret_access_key="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
)
```

GOOD:
```python
import boto3

# Uses AWS credential chain: env vars -> ~/.aws/credentials -> IAM role
client = boto3.client("s3")
```

### Go

BAD:
```go
db, err := sql.Open("postgres",
    "host=db.example.com user=admin password=s3cret dbname=prod")
```

GOOD:
```go
connStr := os.Getenv("DATABASE_URL")
if connStr == "" {
    log.Fatal("DATABASE_URL environment variable is required")
}
db, err := sql.Open("postgres", connStr)
```

### Java

BAD:
```java
String apiKey = "sk-proj-abc123def456";
OpenAiService service = new OpenAiService(apiKey);
```

GOOD:
```java
String apiKey = System.getenv("OPENAI_API_KEY");
Objects.requireNonNull(apiKey, "OPENAI_API_KEY environment variable is required");
OpenAiService service = new OpenAiService(apiKey);
```

### Ruby

BAD:
```ruby
Stripe.api_key = "sk_live_abc123def456"
```

GOOD:
```ruby
Stripe.api_key = ENV.fetch("STRIPE_API_KEY")
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Next.js | Hardcoding keys in `next.config.js` instead of using `NEXT_PUBLIC_` env vars |
| Django | Leaving `SECRET_KEY` as the generated default in `settings.py` |
| FastAPI | Inlining database URLs in `app.py` instead of using pydantic `Settings` |
| Rails | Committing `config/master.key` or putting secrets in `database.yml` |
| Express | Putting JWT secret directly in `app.use(jwt({ secret: "mysecret" }))` |

---

## 2. Missing Input Validation

**OWASP:** [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/)

**AI tendency:** Models generate code that processes the "happy path" input. They rarely add length limits, type checks, or format validation unless explicitly prompted. This is the most frequent AI vulnerability because it affects every input surface.

### Python (FastAPI)

BAD:
```python
@app.post("/transfer")
async def transfer(data: dict):
    amount = data["amount"]
    db.execute(f"UPDATE accounts SET balance = balance - {amount}")
```

GOOD:
```python
class TransferRequest(BaseModel):
    amount: Decimal = Field(gt=0, le=1_000_000, decimal_places=2)
    to_account: str = Field(pattern=r"^[A-Z0-9]{10,34}$")

@app.post("/transfer")
async def transfer(data: TransferRequest):
    db.execute("UPDATE accounts SET balance = balance - %s", (data.amount,))
```

### Go

BAD:
```go
func handleUpload(w http.ResponseWriter, r *http.Request) {
    file, _, _ := r.FormFile("document")
    data, _ := io.ReadAll(file)
    os.WriteFile("/uploads/"+r.FormValue("name"), data, 0644)
}
```

GOOD:
```go
func handleUpload(w http.ResponseWriter, r *http.Request) {
    r.Body = http.MaxBytesReader(w, r.Body, 10<<20) // 10MB limit
    file, header, err := r.FormFile("document")
    if err != nil {
        http.Error(w, "Invalid upload", http.StatusBadRequest)
        return
    }
    defer file.Close()

    ext := filepath.Ext(header.Filename)
    if ext != ".pdf" && ext != ".txt" {
        http.Error(w, "Unsupported file type", http.StatusBadRequest)
        return
    }
    safeName := uuid.New().String() + ext
    data, _ := io.ReadAll(io.LimitReader(file, 10<<20))
    os.WriteFile(filepath.Join("/uploads", safeName), data, 0644)
}
```

### Java

BAD:
```java
@PostMapping("/search")
public List<Product> search(@RequestParam String query) {
    return productRepo.findByNameContaining(query);
}
```

GOOD:
```java
@PostMapping("/search")
public List<Product> search(
        @RequestParam @Size(min = 1, max = 100) @Pattern(regexp = "^[\\w\\s-]+$") String query) {
    return productRepo.findByNameContaining(query);
}
```

### Ruby (Rails)

BAD:
```ruby
def update
  @user.update(params[:user])
end
```

GOOD:
```ruby
def update
  @user.update(user_params)
end

private

def user_params
  params.require(:user).permit(:name, :email)
end
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express | No `express-validator` or `zod` on route handlers |
| Next.js | Server actions that trust client-side form data without re-validation |
| Django | Using `ModelForm` without explicit `fields` (exposes all model fields) |
| FastAPI | Using `dict` instead of Pydantic models for request bodies |
| Rails | Using `params.permit!` (permits everything) instead of strong parameters |

---

## 3. SQL/NoSQL Injection

**OWASP:** [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/)

**AI tendency:** Models default to string interpolation for building queries because it reads more naturally than parameterized statements. This is especially common with f-strings in Python and template literals in JavaScript.

### Python

BAD:
```python
cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")
```

GOOD:
```python
cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
```

### Go

BAD:
```go
query := fmt.Sprintf("SELECT * FROM users WHERE email = '%s'", email)
rows, err := db.Query(query)
```

GOOD:
```go
rows, err := db.Query("SELECT * FROM users WHERE email = $1", email)
```

### Java

BAD:
```java
String sql = "SELECT * FROM users WHERE id = " + userId;
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);
```

GOOD:
```java
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
stmt.setInt(1, userId);
ResultSet rs = stmt.executeQuery();
```

### Ruby (ActiveRecord)

BAD:
```ruby
User.where("name = '#{params[:name]}'")
```

GOOD:
```ruby
User.where(name: params[:name])
# or: User.where("name = ?", params[:name])
```

### NoSQL (MongoDB)

BAD:
```javascript
const user = await db.collection("users").findOne({ username: req.body.username });
// If req.body.username is { "$ne": "" }, this returns the first user
```

GOOD:
```javascript
const username = String(req.body.username); // force to string
if (typeof req.body.username !== "string") return res.status(400).send("Invalid input");
const user = await db.collection("users").findOne({ username });
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express + Sequelize | Using `sequelize.query()` with string interpolation instead of replacements |
| Django | Using `raw()` or `extra()` with f-strings instead of params |
| FastAPI + SQLAlchemy | Using `text()` with f-strings instead of `text().bindparams()` |
| Rails | Using `find_by_sql` with string interpolation |
| Next.js + Prisma | Using `$queryRaw` with template literals (use `$queryRaw` tagged template or `Prisma.sql`) |

---

## 4. Command Injection

**OWASP:** [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/)

**AI tendency:** Models reach for shell execution because it solves problems quickly. They use shell-based execution over argument-list-based alternatives, and rarely add input validation before passing data to shells.

### Python

BAD:
```python
os.system(f"convert {input_file} {output_file}")
```

GOOD:
```python
subprocess.run(["convert", input_file, output_file], check=True, capture_output=True)
```

### Go

BAD:
```go
out, err := exec.Command("sh", "-c", "ping -c 1 "+host).Output()
```

GOOD:
```go
if matched, _ := regexp.MatchString(`^[a-zA-Z0-9.-]+$`, host); !matched {
    return fmt.Errorf("invalid hostname")
}
out, err := exec.Command("ping", "-c", "1", host).Output()
```

### Java

BAD:
```java
Runtime.getRuntime().exec("sh -c nslookup " + userInput);
```

GOOD:
```java
ProcessBuilder pb = new ProcessBuilder("nslookup", userInput);
pb.redirectErrorStream(true);
Process p = pb.start();
```

### Ruby

BAD:
```ruby
result = `ls #{params[:directory]}`
```

GOOD:
```ruby
require "shellwords"
# Better: avoid shell entirely
result = Dir.entries(params[:directory]).join("\n")
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express | Using `child_process.exec()` with string concatenation instead of `execFile()` with args array |
| Django | Using `os.system()` in management commands |
| FastAPI | Using `subprocess.run(shell=True)` instead of passing args as list |
| Rails | Using backticks or `system()` with string interpolation |
| Next.js | Shelling out in API routes or server actions |

---

## 5. Path Traversal

**OWASP:** [A01:2021 - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)

**AI tendency:** Models join user-provided filenames to base paths without checking for `..` sequences or symbolic links. They rarely use `path.resolve()` and almost never verify the resolved path stays within the intended directory.

### Python

BAD:
```python
@app.get("/download")
def download(filename: str):
    return FileResponse(f"/data/reports/{filename}")
```

GOOD:
```python
@app.get("/download")
def download(filename: str):
    safe_name = Path(filename).name  # strips directory components
    file_path = Path("/data/reports") / safe_name
    if not file_path.resolve().is_relative_to(Path("/data/reports").resolve()):
        raise HTTPException(status_code=403, detail="Forbidden")
    return FileResponse(file_path)
```

### Go

BAD:
```go
http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, r.URL.Path[1:])
})
```

GOOD:
```go
http.Handle("/static/", http.StripPrefix("/static/",
    http.FileServer(http.Dir("./public"))))
// http.Dir prevents traversal outside the specified directory
```

### Java

BAD:
```java
@GetMapping("/files/{name}")
public ResponseEntity<Resource> getFile(@PathVariable String name) {
    Path path = Paths.get("/uploads/" + name);
    Resource resource = new FileSystemResource(path);
    return ResponseEntity.ok(resource);
}
```

GOOD:
```java
@GetMapping("/files/{name}")
public ResponseEntity<Resource> getFile(@PathVariable String name) {
    Path basePath = Paths.get("/uploads").toAbsolutePath().normalize();
    Path filePath = basePath.resolve(name).toAbsolutePath().normalize();
    if (!filePath.startsWith(basePath)) {
        return ResponseEntity.status(403).build();
    }
    Resource resource = new FileSystemResource(filePath);
    return ResponseEntity.ok(resource);
}
```

### Ruby

BAD:
```ruby
send_file Rails.root.join("uploads", params[:filename])
```

GOOD:
```ruby
safe_name = File.basename(params[:filename])
file_path = Rails.root.join("uploads", safe_name).to_s
unless file_path.start_with?(Rails.root.join("uploads").to_s)
  head :forbidden
  return
end
send_file file_path
```

---

## 6. Insecure Defaults

**OWASP:** [A05:2021 - Security Misconfiguration](https://owasp.org/Top10/A05_2021-Security_Misconfiguration/)

**AI tendency:** Models optimize for "it works" over "it's secure." They generate permissive CORS, bind to all interfaces, enable debug mode, and use weak session configurations because that is what gets the code running fastest.

### Python (Django)

BAD:
```python
# settings.py
DEBUG = True
ALLOWED_HOSTS = ["*"]
CORS_ALLOW_ALL_ORIGINS = True
```

GOOD:
```python
# settings.py
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "localhost").split(",")
CORS_ALLOWED_ORIGINS = os.getenv("CORS_ORIGINS", "").split(",")
```

### Python (FastAPI)

BAD:
```python
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"])
```

GOOD:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "").split(","),
    allow_methods=["GET", "POST"],
    allow_headers=["Authorization", "Content-Type"],
)
```

### Go

BAD:
```go
srv := &http.Server{Addr: ":8080"}  // binds all interfaces, no timeouts
```

GOOD:
```go
srv := &http.Server{
    Addr:         "127.0.0.1:8080",
    ReadTimeout:  10 * time.Second,
    WriteTimeout: 10 * time.Second,
    IdleTimeout:  120 * time.Second,
}
```

### Java (Spring Boot)

BAD:
```yaml
# application.yml
server:
  address: 0.0.0.0
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

GOOD:
```yaml
# application.yml
server:
  address: 127.0.0.1
management:
  endpoints:
    web:
      exposure:
        include: health,info
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express | No `helmet()` middleware; missing `express-rate-limit` |
| Next.js | Missing `Content-Security-Policy` headers in `next.config.js` |
| Django | `DEBUG = True` in production; `SECURE_SSL_REDIRECT = False` |
| FastAPI | CORS `allow_origins=["*"]`; no rate limiting |
| Rails | `config.force_ssl = false`; `protect_from_forgery` disabled |

---

## 7. Missing Auth Checks

**OWASP:** [A01:2021 - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)

**AI tendency:** Models generate CRUD endpoints that work correctly but have no authentication or authorization. They build the functionality first and "forget" to add the security layer, because nothing in the prompt reminded them to do it.

### Python (FastAPI)

BAD:
```python
@app.delete("/api/posts/{post_id}")
async def delete_post(post_id: int):
    await db.execute("DELETE FROM posts WHERE id = $1", post_id)
    return {"deleted": True}
```

GOOD:
```python
@app.delete("/api/posts/{post_id}")
async def delete_post(post_id: int, user: User = Depends(get_current_user)):
    post = await db.fetchrow("SELECT * FROM posts WHERE id = $1", post_id)
    if not post or post["author_id"] != user.id:
        raise HTTPException(status_code=403, detail="Forbidden")
    await db.execute("DELETE FROM posts WHERE id = $1", post_id)
    return {"deleted": True}
```

### Go

BAD:
```go
r.HandleFunc("/admin/users", listUsersHandler).Methods("GET")
```

GOOD:
```go
r.Handle("/admin/users", authMiddleware(adminOnly(http.HandlerFunc(listUsersHandler)))).Methods("GET")
```

### Java (Spring)

BAD:
```java
@DeleteMapping("/api/users/{id}")
public void deleteUser(@PathVariable Long id) {
    userRepository.deleteById(id);
}
```

GOOD:
```java
@DeleteMapping("/api/users/{id}")
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(@PathVariable Long id, @AuthenticationPrincipal UserDetails user) {
    userRepository.deleteById(id);
    auditLog.record(user.getUsername(), "DELETE_USER", id);
}
```

### Ruby (Rails)

BAD:
```ruby
class AdminController < ApplicationController
  def destroy
    User.find(params[:id]).destroy
  end
end
```

GOOD:
```ruby
class AdminController < ApplicationController
  before_action :authenticate_user!
  before_action :require_admin

  def destroy
    User.find(params[:id]).destroy
  end

  private

  def require_admin
    head :forbidden unless current_user.admin?
  end
end
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express | No `passport` or auth middleware on sensitive routes |
| Next.js | API routes without `getServerSession()` or middleware auth check |
| Django | Missing `@login_required` or `@permission_required` decorators |
| FastAPI | No `Depends(get_current_user)` on protected endpoints |
| Rails | Missing `before_action :authenticate_user!` in controllers |

---

## 8. Verbose Error Responses

**OWASP:** [A09:2021 - Security Logging and Monitoring Failures](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/)

**AI tendency:** Models return the full error object to the client because it is helpful for debugging. They do not distinguish between development and production error handling. Stack traces, SQL queries, file paths, and internal service names are all exposed.

### Python (FastAPI)

BAD:
```python
@app.exception_handler(Exception)
async def error_handler(request, exc):
    return JSONResponse(
        status_code=500,
        content={"error": str(exc), "trace": traceback.format_exc()}
    )
```

GOOD:
```python
@app.exception_handler(Exception)
async def error_handler(request, exc):
    logger.exception("Unhandled error", extra={"path": request.url.path})
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error"}
    )
```

### Go

BAD:
```go
if err != nil {
    http.Error(w, fmt.Sprintf("Database error: %v", err), 500)
}
```

GOOD:
```go
if err != nil {
    log.Printf("database error on %s: %v", r.URL.Path, err)
    http.Error(w, "Internal server error", http.StatusInternalServerError)
}
```

### Java

BAD:
```java
@ExceptionHandler(Exception.class)
public ResponseEntity<Map<String, Object>> handleError(Exception ex) {
    Map<String, Object> body = Map.of(
        "error", ex.getMessage(),
        "stackTrace", Arrays.toString(ex.getStackTrace())
    );
    return ResponseEntity.status(500).body(body);
}
```

GOOD:
```java
@ExceptionHandler(Exception.class)
public ResponseEntity<Map<String, String>> handleError(Exception ex) {
    log.error("Unhandled exception", ex);
    return ResponseEntity.status(500).body(Map.of("error", "Internal server error"));
}
```

### Ruby (Rails)

BAD:
```ruby
rescue_from StandardError do |e|
  render json: { error: e.message, backtrace: e.backtrace }, status: 500
end
```

GOOD:
```ruby
rescue_from StandardError do |e|
  Rails.logger.error("#{e.class}: #{e.message}\n#{e.backtrace&.first(5)&.join("\n")}")
  render json: { error: "Internal server error" }, status: 500
end
```

### Framework Gotchas

| Framework | Common AI Mistake |
|-----------|-------------------|
| Express | Default error handler sends full stack trace; no custom error middleware |
| Next.js | `getServerSideProps` errors expose internal details in dev mode |
| Django | `DEBUG = True` shows full tracebacks to users |
| FastAPI | Default exception handler exposes validation error details |
| Rails | `config.consider_all_requests_local = true` in production |

---

## AI Model-Specific Tendencies

Observed patterns across major AI coding models:

| Pattern | Frequency | Models Most Affected |
|---------|-----------|---------------------|
| `cors({ origin: "*" })` | Very high | All models |
| Hardcoded `sk-` or `AKIA` prefixes | High | GPT-4, Claude |
| Shell execution with string concat | High | All models |
| String interpolation in SQL | Very high | GPT-4, GPT-3.5, Gemini |
| Missing auth middleware | High | All models |
| `DEBUG = True` in generated configs | Medium | GPT-4, Claude |
| `eval()` for JSON parsing | Medium | GPT-3.5, Gemini |
| `chmod 777` in setup scripts | Low-medium | All models |
| Logging sensitive request bodies | Medium | All models |
| JWT with hardcoded secret | High | All models |

These tendencies are based on patterns observed in public benchmarks and security audits of AI-generated code (Stanford 2024, Snyk 2024, GitGuardian 2024). Individual model versions and system prompts affect output; always verify regardless of model.
